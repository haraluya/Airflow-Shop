

# **Airflow 專案軟體需求規格文件 (SRS)**

## **1\. 系統總覽與核心架構**

### **1.1. 執行摘要**

本文件旨在詳細定義「Airflow」專案的軟體需求規格。Airflow 是一個專為電子煙批發產業量身打造的整合性 B2B 電商與客戶關係管理 (CRM) 平台。此系統的核心目標是取代零散的工作流程，提供一個統一、高效且個人化的解決方案 1。

專案的主要目標可歸納如下：

1. **系統整合**：建立一個集 B2B 批發下單、客戶關係管理 (CRM)、產品與訂單管理於一體的特製商城系統。  
2. **個人化體驗**：根據不同的客戶群體與來源，自動展示客製化的商品價格、專屬的行銷橫幅及業務聯絡資訊。  
3. **高效後台管理**：提供一個功能強大的管理後台，使管理員能夠全面控制前台內容，並具備代客下單等核心營運功能。  
4. **業務績效追蹤**：透過推薦碼系統，精確追蹤不同業務員的訂單來源與客戶歸屬，並提供可匯出的績效報表。  
5. **系統過渡方案**：實現後台訂單與 Notion 資料庫的雙向同步，作為銜接舊有工作流程的過渡方案。此功能將被設計為可獨立移除的模組 1。

本文件將作為開發團隊在設計、開發、測試及部署階段的主要指導性文件，確保最終交付的產品能完全符合業務需求。

### **1.2. 使用者角色與權限**

系統定義了三種主要的使用者角色，各自擁有明確的職責與權限邊界 1。

* **管理員 (Administrator)**  
  * **職責**：負責系統的日常營運與維護。管理產品目錄、客戶資料、訂單處理、價格策略、前台內容以及業務推薦碼系統。  
  * **權限**：擁有系統的最高權限。可對所有模組進行完整的 CRUD (建立、讀取、更新、刪除) 操作。具備特殊權限，如審核新客戶註冊、手動調整客戶歸屬的業務員，以及代表客戶從後台建立訂單（代客下單）。  
* **客戶 (Customer / Wholesaler)**  
  * **職責**：作為系統的主要使用者，進行商品瀏覽、下單採購、管理個人帳戶資訊及查看訂單狀態。  
  * **權限**：僅能存取前台系統。在通過管理員審核並啟用帳號後，可登入系統。登入後可查看根據其身份（所屬價格群組或特定設定）顯示的專屬商品價格。客戶可對自己的帳戶資料、多個送貨地址進行 CRUD 操作，並可建立訂單、查看歷史訂單與系統通知。  
* **業務員 (Salesperson)**  
  * **職責**：負責引導新客戶透過其專屬的推薦碼連結進行註冊與下單，並透過後台追蹤自身業績與客戶狀態。  
  * **權限**：**擁有受限制的後台登入權限**。登入後可進入專屬的「業務員門戶」，在此門戶中：  
    * **可讀取**：查看與自身推薦碼關聯的客戶列表、訂單記錄及績效儀表板。  
    * **可編輯**：修改與自身推薦碼頁面相關的個人化設定，例如更新自己的 LINE ID 與 LINE QR Code 圖片。  
    * **權限隔離**：**嚴格禁止**存取、查看或修改任何不屬於自己的客戶資料、訂單記錄或其他業務員的個人化設定。

### **1.3. 系統架構圖**

本系統採用現代化的全端 Serverless 架構，以 Google Cloud Platform 的 Firebase 生態系為核心，結合 Next.js 框架，旨在實現高效能、高可擴展性與低維運成本。

**架構分層說明：**

* **第一層 (用戶端 Client)**：使用 Next.js 14 (App Router) 與 React 18 建構的單頁應用程式 (SPA)，運行於使用者的瀏覽器中。此層負責渲染使用者介面 (UI) 並處理使用者互動。  
* **第二層 (託管與邊緣網路 Hosting & Edge)**：使用 Firebase Hosting 服務。此服務負責全球分發靜態資源（如 JavaScript、CSS、圖片），並作為流量入口，將請求路由至後端服務。  
* **第三層 (無伺服器後端 Serverless Backend)**：  
  * **Firebase Functions**：作為系統的核心運算層。用於處理 Next.js 的伺服器端渲染 (SSR)、執行 API 端點邏輯（如訂單處理、客戶驗證）、以及與外部服務（如 Notion API）的整合。  
  * **Firebase Authentication**：提供完整的身份驗證解決方案，管理使用者註冊、登入、密碼重設及會話管理。  
* **第四層 (資料與儲存 Data & Storage)**：  
  * **Firestore**：作為主要的 NoSQL 資料庫，以文件集合 (Collections/Documents) 的形式儲存所有業務資料，如使用者、產品、訂單等。其彈性的結構特別適合電商應用的演進需求。  
  * **Firebase Storage**：用於儲存非結構化檔案，如產品圖片、業務員的 LINE QR Code 圖片等。  
* **第五層 (外部服務 External Services)**：與 Notion API 進行整合，實現訂單資料的雙向同步功能。

此架構的選擇帶來了顯著的優勢，但也伴隨著特定的權衡。完全無伺服器的設計雖然提供了極佳的擴展性並免除了伺服器管理的負擔，但 Firebase Functions 的「冷啟動 (cold start)」延遲是需要納入考量的效能因素。對於不常被觸發的函式，首次調用時可能會有數百毫秒至數秒的延遲，這可能會輕微影響到首次載入特定伺服器渲染頁面或呼叫特定 API 的使用者體驗 2。

### **1.4. 技術棧選擇理由**

專案所選的技術棧是基於現代 Web 開發的最佳實踐，旨在平衡開發效率、系統效能與長期可維護性 1。

* **前端 (Frontend) \- Next.js 14 (App Router), React 18, TypeScript**：Next.js 作為領先的 React 框架，其 App Router 提供了強大的伺服器端渲染 (SSR) 與靜態網站生成 (SSG) 能力，有助於提升 SEO 與首頁載入效能。TypeScript 的引入則為專案帶來了型別安全，能大幅減少執行時錯誤，提升程式碼的健壯性。  
* **後端與基礎設施 (Backend & Infrastructure) \- Firebase**：Firebase 提供了一整套的後端即服務 (BaaS)，包含 Functions、Firestore、Authentication 及 Storage。這使得開發團隊能專注於業務邏輯的實現，而非底層基礎設施的建置與維護。其按需付費的模式在專案初期也能有效控制成本 2。  
* **UI 函式庫與樣式 (UI Library & Styling) \- Radix UI \+ Tailwind CSS**：此組合是實現高度客製化與一致性設計系統的最佳選擇。Radix UI 提供了無樣式、功能完整且符合無障礙 (Accessibility) 標準的基礎 UI 元件 1。Tailwind CSS 則是一個功能優先 (Utility-First) 的 CSS 框架，讓開發者能快速地在 HTML 中直接建構複雜的介面，同時透過設定檔集中管理設計系統（顏色、間距、字型等），完美符合專案「UI 集中管理」與「避免硬編碼」的架構原則 1。

## **2\. 全域風格指南與 UI/UX 原則**

本節旨在建立一個貫穿整個應用程式的設計系統，確保所有頁面與元件在視覺與互動上保持高度一致性與專業性。

### **2.1. 設計哲學**

系統的 UI/UX 設計將遵循以下核心原則 1：

* **行動裝置優先 (Mobile-First Responsive Design)**：所有元件與頁面佈局的設計流程將從最小的行動裝置視口開始，逐步擴展至平板與桌面裝置。這確保了在各種尺寸的螢幕上都能提供最佳的使用體驗。  
* **無障礙設計 (Accessibility, WCAG 2.1 AA)**：系統將充分利用 Radix UI 元件庫內建的無障礙特性，例如正確的 ARIA 屬性、鍵盤導航支援等，確保應用程式對於身心障礙使用者依然友好且可用。  
* **視覺一致性與內聚力 (Visual Cohesion)**：嚴格遵守本節定義的色彩、字體排版、間距與元件使用規則。所有設計元素都應來自於統一的設計權杖 (Design Tokens)，以實現「UI 集中管理」的目標，避免在個別頁面出現風格不一致的獨立樣式。

### **2.2. 色彩規範**

為支援淺色與深色模式切換（由 next-themes 函式庫管理），系統將定義一套語意化的色彩權杖。所有顏色值都應在 tailwind.config.js 中進行設定，開發時應使用權杖名稱（如 bg-primary），而非直接使用 HEX 色碼 1。

**表 2.1：應用程式色彩權杖**

| 權杖名稱 | 淺色模式 (HEX) | 深色模式 (HEX) | 用途說明 |
| :---- | :---- | :---- | :---- |
| clr-primary-start | \#FFA500 (橘) | \#FF8C00 | 主要漸層主題色的起始色，用於按鈕、焦點元素。 |
| clr-primary-end | \#0000FF (藍) | \#4169E1 | 主要漸層主題色的結束色。 |
| clr-text-primary | \#1F2937 (灰-800) | \#F9FAFB (灰-50) | 主要內文、標題文字顏色。 |
| clr-text-secondary | \#6B7280 (灰-500) | \#9CA3AF (灰-400) | 輔助文字、提示訊息、佔位符文字。 |
| clr-bg-primary | \#FFFFFF | \#111827 (灰-900) | 頁面主要背景色。 |
| clr-bg-secondary | \#F3F4F6 (灰-100) | \#1F2937 (灰-800) | 卡片、輸入框、模組區塊的背景色。 |
| clr-accent-success | \#10B981 (綠-500) | \#34D399 (綠-400) | 成功提示、驗證通過狀態。 |
| clr-accent-error | \#EF4444 (紅-500) | \#F87171 (紅-400) | 錯誤提示、刪除操作、警示狀態。 |
| clr-border-primary | \#E5E7EB (灰-200) | \#374151 (灰-700) | 元件的主要邊框顏色。 |

這種將設計決策抽象化為權杖的作法，是「避免硬編碼」原則在樣式層面的具體實踐。它確保了未來若需調整品牌主色調（例如將橘色微調），只需修改設定檔中的一個值，變更就會自動應用於全站所有相關元件，極大地提升了系統的可維護性。

### **2.3. 字體排版系統**

系統將採用統一的字體排版規範，以確保資訊層次的清晰與閱讀的舒適性。

* **字體家族 (Font Family)**：Inter (或其他高品質的無襯線字體，待最終確認)。  
* **排版尺度 (Type Scale)**：定義一組全域的 CSS class，對應不同的語意層級，並包含響應式設定。

| 類別名稱 | 字體大小 (Mobile / Desktop) | 字重 (Font Weight) | 行高 (Line Height) | 用途 |
| :---- | :---- | :---- | :---- | :---- |
| text-h1 | 36px / 48px | 800 (ExtraBold) | 1.2 | 頁面主標題 |
| text-h2 | 28px / 36px | 700 (Bold) | 1.3 | 區塊主標題 |
| text-h3 | 22px / 24px | 600 (SemiBold) | 1.4 | 子標題 |
| text-body-lg | 18px / 18px | 400 (Regular) | 1.6 | 大號內文 |
| text-body-md | 16px / 16px | 400 (Regular) | 1.6 | 標準內文、輸入框文字 |
| text-body-sm | 14px / 14px | 400 (Regular) | 1.5 | 輔助性、較小的文字 |
| text-caption | 12px / 12px | 400 (Regular) | 1.4 | 註解、圖說文字 |

### **2.4. 核心元件庫 (基於 Radix UI \+ Tailwind CSS)**

以下定義系統中常用核心元件的設計規範，所有客製化元件都應基於此規範進行擴展。

* **按鈕 (Button)**：  
  * **元件**：單一的 \<Button\> 元件。  
  * **變體 (Variants)**：  
    * primary：漸層背景 (clr-primary-start 至 clr-primary-end)，白色文字。用於最重要的操作，如「加入購物車」、「提交訂單」。  
    * secondary：透明背景，clr-primary-start 邊框與文字。用於次要操作，如「取消」、「返回列表」。  
    * ghost：透明背景，無邊框，clr-text-primary 文字。用於低干擾性操作。  
    * destructive：clr-accent-error 背景，白色文字。用於具破壞性的操作，如「刪除客戶」。  
  * **狀態 (States)**：需明確定義 default, hover, active, disabled 四種狀態下的視覺樣式（如背景色變化、透明度降低等）。  
* **表單元件 (Form Elements)**：  
  * **輸入框 (Input), 文字區 (Textarea), 下拉選單 (Select)**：  
    * **預設狀態**：背景色為 clr-bg-secondary，邊框為 clr-border-primary。  
    * **焦點狀態 (:focus)**：邊框顏色變為 clr-primary-start，並帶有微弱的同色系外光暈。  
    * **錯誤狀態**：邊框顏色變為 clr-accent-error。  
    * **禁用狀態 (:disabled)**：背景色變為更淺的灰色，文字顏色為 clr-text-secondary，滑鼠指標變為 not-allowed。  
* **卡片 (Card)**：  
  * 標準化的卡片容器，用於產品列表、儀表板小工具等。  
  * **樣式**：背景色為 clr-bg-secondary，帶有圓角 (8px) 和細微的陰影效果。  
* **模態框 (Modal)**：  
  * 用於顯示重要資訊或需要使用者確認的操作。  
  * **樣式**：包含一個半透明的黑色遮罩層 (rgba(0,0,0,0.5))。模態框本身背景為 clr-bg-primary，帶有圓角和陰影。內容區域應有足夠的內邊距 (padding)。操作按鈕應置於右下角，通常包含一個 primary 按鈕和一個 secondary 按鈕。

## **3\. 資料模型 (Firestore Schema)**

本節詳細定義了 Firestore 資料庫的結構。所有集合 (Collection) 與文件 (Document) 的欄位都經過精心設計，以滿足功能需求、查詢效率與安全性考量。

### **3.1. users 集合**

此集合儲存所有系統使用者的核心身份資訊，文件 ID (uid) 直接對應 Firebase Authentication 的使用者 ID。

**表 3.1：users 集合文件結構**

| 欄位名稱 | 資料型別 | 描述 | 備註 |
| :---- | :---- | :---- | :---- |
| uid | String | 文件 ID，與 Firebase Auth uid 相同。 | 主鍵 |
| email | String | 使用者的登入電子郵件。 | 唯一，需索引 |
| role | String | 使用者角色。枚舉值: "admin", "customer", "salesperson"。 | 用於權限控制 |
| status | String | 帳號狀態 (僅限 customer 角色)。枚舉值: "pending\_approval", "active", "rejected"。 |  |
| displayName | String | 使用者姓名或公司名稱。 |  |
| sourceDescription | String | 客戶註冊時填寫的「來源說明」1。 |  |
| referralCodeId | String | 關聯的 referralCodes 文件 ID。 | 必填，用於追蹤業務來源 |
| createdAt | Timestamp | 帳號建立時間，由伺服器生成。 |  |
| updatedAt | Timestamp | 資料最後更新時間，由伺服器生成。 |  |

### **3.2. customers 子集合**

此子集合嵌套於 users 文件之下 (路徑: /users/{uid}/customers/{uid}），專門儲存客戶的 CRM 相關資訊。這種嵌套結構是基於安全性的重要設計決策。

將 CRM 資料直接置於其對應的使用者文件之下，可以輕易地撰寫 Firestore 安全規則，確保任何客戶都只能讀取和寫入自己的 CRM 資料，而無法存取其他客戶的資訊。例如，安全規則可以設定為 allow read, write: if request.auth.uid \== userId;。這直接且有效地實現了專案對客戶資料嚴格隔離的安全要求 1。

**表 3.2：customers 子集合文件結構**

| 欄位名稱 | 資料型別 | 描述 | 備註 |
| :---- | :---- | :---- | :---- |
| tags | Array of Strings | CRM 標籤，如 "高價值客戶", "新品愛好者"。 |  |
| source | String | CRM 客戶來源，如 "業務A推薦", "展會"。 |  |
| preferredItems | Array of Strings | 偏好品項的產品 ID 列表。 |  |
| lastPurchaseDate | Timestamp | 最後一次成功下單的日期。 | 每次訂單完成時更新 |
| notes | String | 內部備忘錄，僅管理員可見。 |  |
| shippingAddresses | Array of Maps | 客戶的多個送貨地址。 | 每個 Map 包含 recipientName, phone, address, isDefault 等欄位。 |
| pricingGroupId | String | 關聯的 pricingGroups 文件 ID。 | 用於群組定價 |
| customPrices | Map | 客戶專屬的商品定價。 | Key 為 productId (String)，Value 為價格 (Number)。 |

### **3.3. products 集合**

儲存所有商品資訊。

**表 3.3：products 集合文件結構**

| 欄位名稱 | 資料型別 | 描述 | 備註 |
| :---- | :---- | :---- | :---- |
| productId | String | 文件 ID，由系統自動生成。 | 主鍵 |
| name | String | 商品名稱。 | 需索引 |
| sku | String | 商品貨號 (Stock Keeping Unit)。 | 唯一，需索引 |
| descriptionHtml | String | 商品描述，儲存由富文本編輯器生成的 HTML 內容。 |  |
| images | Array of Strings | 商品圖片的公開 URL 列表。 | URL 指向 Firebase Storage |
| standardPrice | Number | 商品的標準售價。 |  |
| category | String | 商品分類。 | 需索引 |
| series | String | 商品系列。 | 需索引 |
| isActive | Boolean | 商品是否上架。 | true 為上架 |
| createdAt | Timestamp | 商品建立時間。 |  |
| updatedAt | Timestamp | 商品最後更新時間。 |  |

### **3.4. orders 集合**

儲存所有訂單資訊。

**表 3.4：orders 集合文件結構**

| 欄位名稱 | 資料型別 | 描述 | 備註 |
| :---- | :---- | :---- | :---- |
| orderId | String | 文件 ID，由系統自動生成。 | 主鍵 |
| orderNumber | String | 對外顯示的訂單編號，可自訂格式。 | 需索引 |
| customerId | String | 下單客戶的 uid。 | 需索引 |
| referralCodeId | String | 訂單來源的推薦碼 ID。 | 需索引，用於業務績效統計 |
| items | Array of Maps | 訂單內的商品項目。 | 每個 Map 包含 productId, name, sku, quantity, price。 |
| totalAmount | Number | 訂單總金額。 |  |
| shippingAddress | Map | 該筆訂單的送貨地址。 |  |
| status | String | 訂單狀態。枚舉值: "pending", "processing", "shipped", "completed", "cancelled"。 | 需索引 |
| notes | String | 訂單備註。 |  |
| createdBy | String | 訂單建立者。枚舉值: "customer", "admin"。 | 區分客戶自行下單或代客下單 |
| createdAt | Timestamp | 訂單建立時間。 |  |
| shippedAt | Timestamp | 出貨時間。 |  |
| notionSync | Map | Notion 同步相關資訊。 | 包含 pageId (String), lastSyncedAt (Timestamp)。 |

### **3.5. 其他核心集合**

* **pricingGroups 集合**：用於管理價格群組。每份文件包含 name (String) 和 prices (Map)，其中 prices 的 Key 為 productId，Value 為該群組的專屬價格。  
* **referralCodes 集合**：儲存業務員的推薦碼資訊。每份文件包含 code (String, URL 後綴)、salespersonName (String)、lineId (String)、lineQrCodeUrl (String) 等 1。  
* **notifications 集合**：儲存發送給客戶的通知。每份文件包含 recipientId (String, 客戶 uid)、title (String)、message (String)、isRead (Boolean) 和 createdAt (Timestamp)。  
* **siteContent 集合**：用於管理前台的動態內容。例如，可以有一份文件專門儲存不同客戶群組對應的首頁橫幅圖片 URL。

## **4\. 前台功能需求 (Frontend)**

### **4.1. 客戶系統**

* **4.1.1. 註冊申請**  
  * **流程**：使用者訪問註冊頁面，需填寫基本資料（公司名稱、聯絡人、Email、密碼）以及一個必填的「來源說明」欄位 1。  
  * **提交後**：提交表單後，系統在 users 集合中建立一筆新文件，role 設為 "customer"，status 設為 "pending\_approval"。頁面顯示「註冊申請已提交，請靜待管理員審核」的訊息。  
* **4.1.2. 登入**  
  * **權限控制**：只有 status 為 "active" 的客戶帳號才能成功登入。若 status 為 "pending\_approval" 或 "rejected"，則顯示對應的提示訊息（例如：「您的帳號尚在審核中」）。  
* **4.1.3. 帳戶資料管理**  
  * **功能**：客戶登入後，可進入「我的帳戶」頁面。  
  * **可編輯欄位**：可修改個人基本資料（如聯絡人、密碼）。  
  * **地址管理**：可新增、編輯、刪除多個送貨地址，並可設定一個預設地址。

### **4.2. 商品瀏覽**

* **4.2.1. 商品列表與詳情頁**  
  * **佈局**：提供標準的商品列表頁（網格或列表視圖）與商品詳情頁。  
  * **內容**：展示商品名稱、圖片、描述（渲染 descriptionHtml 欄位的內容）等資訊。  
* **4.2.2. 價格顯示權限**  
  * **未登入狀態**：網站不顯示任何價格資訊。價格欄位將被隱藏或顯示為「登入後查看價格」。  
  * **登入後狀態**：系統將根據當前登入客戶的身份，調用後端的價格引擎邏輯，顯示最終的專屬價格。

### **4.3. 購物流程**

* **4.3.1. 權限控制**  
  * **觸發**：若未登入的訪客嘗試執行任何購物相關操作（如點擊「加入購物車」按鈕）。  
  * **響應**：系統應彈出一個模態框或跳轉至提示頁面，顯示訊息「請先登入或申請帳號」，並提供前往登入/註冊頁面的連結 1。  
* **4.3.2. 已登入購物流程**  
  * **購物車**：標準的購物車功能，可增減商品數量、移除商品。  
  * **結帳**：進入結帳頁面後，客戶可以從已儲存的地址列表中選擇送貨地址，或即時新增一個新地址。  
  * **下單**：確認訂單資訊後提交，系統建立一筆新的 orders 文件。

### **4.4. 訂單查詢**

* **功能**：客戶登入後，可進入「我的訂單」頁面，查看自己所有歷史訂單的列表。  
* **顯示資訊**：列表應顯示訂單編號、下單日期、總金額、訂單狀態。點擊可進入訂單詳情頁，查看更完整的資訊。

### **4.5. 通知中心**

* **入口**：客戶登入後，頁面頂部的導航欄應有一個通知圖示（例如：鈴鐺），並顯示未讀通知數量。  
* **內容**：點擊圖示後，會以下拉選單或獨立頁面的形式，展示由後台發送的通知列表。  
* **通知類型**：包括訂單狀態更新（已出貨、已完成）、訂單問題提醒（缺貨、地址不清）、系統公告等 1。

### **4.6. 客製化與分銷**

* **4.6.1. 推薦碼識別與內容個人化**  
  * **URL 結構**：系統透過 domain.com/\[推薦碼\] 的 URL 格式來識別來源業務員 1。  
  * **綁定邏輯**：  
    1. 新用戶透過此類 URL 訪問網站並完成註冊，其 users 文件中的 referralCodeId 將自動綁定至該推薦碼。  
    2. 每位客戶都必須關聯一個推薦碼。若訪客直接訪問根域名，系統應將其重導向至一個預設的推薦碼頁面（例如 domain.com/default）。  
  * **內容展示**：  
    1. **業務資訊**：根據訪客 URL 中的推薦碼，前台頁面的特定位置（如頁首或頁尾）會顯示對應業務員的 LINE 聯絡資訊（ID 與 QR Code 圖片）1。  
    2. **首頁橫幅**：客戶登入後，系統會根據其所屬的客戶群組（或 pricingGroupId），顯示不同的首頁橫幅圖片。  
* **4.6.2. 強制 URL 導向**  
  * **機制**：為確保業務歸屬的明確性，已登入的客戶，無論他們從哪個 URL 進入網站，系統都應在客戶端或伺服器端檢查其綁定的 referralCodeId，並自動將其 URL 重寫或重導向至其原始綁定的推薦碼網址（例如 domain.com/abc）1。

## **5\. 後台功能需求 (Backend)**

### **5.1. 儀表板 (Dashboard)**

* **功能**：管理員登入後台的首頁。  
* **內容**：以卡片和圖表的形式，展示關鍵營運數據摘要，例如：今日訂單數、待處理訂單、待審核客戶數、本月銷售總額等。

### **5.2. 訂單管理**

* **5.2.1. 訂單列表與篩選**  
  * **列表顯示**：展示所有訂單的列表，並明確標示每筆訂單的來源推薦碼與對應的業務員名稱。  
  * **篩選功能**：提供強大的篩選器，可依據訂單狀態、日期範圍、客戶名稱、以及**業務員**進行篩選。  
* **5.2.2. 報表匯出**  
  * **功能**：提供一個報表匯出功能，允許管理員篩選特定業務員及月份，生成並下載該業務員的月度銷售報表（CSV 或 Excel 格式）。  
  * **報表欄位**：應包含訂單編號、完成日期、客戶名稱、訂單總金額、佣金（若適用）等。  
* **5.2.3. 代客下單**  
  * **流程**：管理員可選擇一位現有客戶，模擬其身份進入購物流程，為其建立訂單。  
  * **標記**：成功建立的訂單，其 orders 文件中的 createdBy 欄位應被標記為 "admin" 1。  
* **5.2.4. 對客通知**  
  * **入口**：在訂單詳情頁面，提供一個「發送通知」的功能區塊。  
  * **功能**：管理員可針對特定訂單向客戶發送通知。例如，輸入「您訂購的商品 A 目前缺貨，預計下週到貨」，點擊發送後，系統會在 notifications 集合中為該客戶建立一筆新通知。

### **5.3. 客戶管理 (CRM)**

* **5.3.1. 客戶列表與詳情**  
  * **列表**：展示所有客戶的列表，包含姓名/公司名、Email、狀態、歸屬業務員等關鍵資訊。  
  * **詳情頁**：點擊客戶可進入詳情頁，查看並編輯其所有 CRM 相關資訊。  
* **5.3.2. 帳號審核**  
  * **介面**：提供一個專門的「待審核客戶」列表頁面。  
  * **操作**：管理員可在此頁面對 status 為 "pending\_approval" 的客戶進行「通過」或「拒絕」操作。通過後，客戶 status 更新為 "active"；拒絕則更新為 "rejected"。  
* **5.3.3. 客戶歸屬管理**  
  * **顯示**：在客戶詳情頁明確顯示其歸屬的業務員。  
  * **調整**：管理員應有權限手動修改客戶的 referralCodeId，以應對業務人員變動等情況。  
* **5.3.4. 客製化 CRM 欄位**  
  * **介面**：在客戶詳情頁提供以下欄位的編輯介面 1：  
    * **客戶標籤 (Tags)**：可新增或移除標籤。  
    * **客戶來源 (Source)**：文本輸入。  
    * **偏好品項 (Preferred Items)**：可從產品列表中選擇多個商品。  
    * **備忘錄 (Notes)**：多行文本輸入框。  
* **5.3.5. 客戶專屬定價頁面**  
  * **功能**：在客戶詳情頁內，提供一個獨立的定價管理介面。  
  * **操作**：此介面允許管理員篩選商品（按分類或名稱），並以列表形式快速為該客戶設定多個商品的客製化單價。儲存後，這些價格會寫入該客戶 customers 文件下的 customPrices Map 中 1。

### **5.4. 產品管理**

* **5.4.1. 商品 CRUD**  
  * **介面**：提供標準的表單介面，用於新增、編輯、刪除商品。  
  * **欄位**：包含商品名稱、SKU、分類、系列、標準價格、上架狀態等。  
* **5.4.2. 富文本編輯器 (Rich Text Editor)**  
  * **技術選型**：產品描述欄位將採用 **Tiptap** 作為富文本編輯器。Tiptap 基於 ProseMirror，是一個「無頭 (headless)」函式庫，這意味著它可以與 Tailwind CSS 完美整合，實現完全客製化的編輯器外觀與工具欄，同時保持輕量與高擴展性 4。  
  * **功能實現**：  
    1. **基本功能**：將配置 Tiptap 的 StarterKit 擴展，以支援 Markdown 語法、粗體、斜體、列表等基本格式 7。  
    2. **圖片上傳**：當管理員在編輯器中插入圖片時，前端會觸發一個上傳流程。圖片檔案將被直接上傳至 Firebase Storage 的指定路徑（例如 /product-images/）8。上傳成功後，獲取該圖片的公開 URL，並將一個  
       \<img\> 標籤插入到編輯器內容中。  
    3. **影片嵌入**：將配置 Tiptap 以支援嵌入 YouTube 影片。使用者只需貼上 YouTube 連結，編輯器即可將其轉換為嵌入式的播放器。  
  * **資料儲存**：編輯器的最終內容將以安全的 HTML 格式儲存於 products 文件的 descriptionHtml 欄位中 10。

### **5.5. 定價管理 (Pricing Engine)**

* **5.5.1. 價格群體管理**  
  * **介面**：提供一個「價格群組」管理頁面，管理員可在此新增、編輯、刪除價格群組。  
  * **設定**：在每個群組的編輯頁面中，管理員可以為該群組設定一系列商品的專屬價格。  
* **5.5.2. 多樣化價格修改模式**  
  1. **單品編輯**：在商品編輯頁面，直接修改「標準價格」。  
  2. **列表快編**：在商品列表頁的表格中，價格欄位應為可點擊編輯狀態。點擊後變為輸入框，修改完成後（失焦或按 Enter）即時儲存。  
  3. **批次修改**：提供一個批次操作工具。管理員可篩選特定「分類」或「系列」的所有商品，然後對這些商品的標準價格進行統一調整，可選擇「上漲 %」、「下跌 %」、「增加固定金額」或「減少固定金額」1。

### **5.6. 內容管理**

* **介面**：提供一個專門的橫幅 (Banner) 管理介面。  
* **功能**：管理員可以上傳圖片，並將其指派給一個或多個客戶群組。前台將根據登入客戶的群組來顯示對應的橫幅。

### **5.7. 推薦碼系統管理**

* **介面**：提供推薦碼的 CRUD 管理介面。  
* **資料欄位**：每個推薦碼應包含以下資料：業務名稱、推薦碼編號 (即 URL 後綴)、LINE ID、LINE 二維碼 (圖片上傳)、備註 1。  
* **操作**：管理員可新增、編輯業務員資訊，或停用某個推薦碼。

### **5.8. 業務員門戶 (Salesperson Portal)**

* **5.8.1. 專屬儀表板**  
  * **功能**：業務員登入後台的首頁，僅顯示與其自身相關的數據。  
  * **內容**：以簡潔的卡片和圖表展示個人績效，例如：本月個人訂單總額、本月新增客戶數、個人名下訂單狀態分佈等。  
* **5.8.2. 個人客戶與訂單查詢**  
  * **客戶列表**：提供一個唯讀的客戶列表，僅顯示透過其推薦碼註冊的客戶。  
  * **訂單列表**：提供一個唯讀的訂單列表，僅顯示源自其名下客戶的訂單。  
  * **權限限制**：業務員無法查看或篩選不屬於自己的客戶或訂單。  
* **5.8.3. 個人化設定管理**  
  * **功能**：提供一個專屬的設定頁面。  
  * **可編輯欄位**：業務員可在此頁面更新自己的 LINE ID、上傳新的 LINE QR Code 圖片，以及修改其他管理員開放的個人化資訊。

## **6\. 深度模組分析**

### **6.1. 價格引擎 (Pricing Engine)**

價格引擎是此 B2B 商城的核心，其邏輯必須清晰且高效。

* **價格解析邏輯**：系統中所有顯示價格的地方，都必須通過一個統一的後端函式 calculatePrice(user, product) 來獲取價格。此函式將嚴格遵循以下優先級順序進行解析 1：  
  1. **客戶特定單價 (最高優先級)**：檢查 user.customers.customPrices Map 中是否存在以 product.productId 為鍵的條目。如果存在，立即返回該價格。  
  2. **客戶群體價格**：如果步驟 1 未找到價格，則檢查 user.customers.pricingGroupId。使用此 ID 查詢 pricingGroups 集合，並在該群組的 prices Map 中查找 product.productId。如果找到，返回該價格。  
  3. **商品標準價格 (最低優先級)**：如果以上步驟均未找到價格，則返回 product.standardPrice。  
* **效能考量**：為確保價格計算的效能，客戶登入時，其 pricingGroupId 和 customPrices 等關鍵定價資訊應被快取在用戶端的會話 (session) 或狀態管理中，避免每次瀏覽商品都需要重新查詢資料庫。對於價格群組的價格表，也可以在後端進行快取。

### **6.2. Notion 雙向同步**

此功能作為過渡方案，其設計必須兼顧即時性、可靠性與模組化，同時要嚴格遵守 Notion API 的限制。

* **架構決策**：Notion API 的速率限制為平均每秒 3 次請求 11。單純的輪詢 (Polling) 策略會迅速耗盡此配額且有延遲 12。而單純依賴 Webhook 則存在事件遺失的風險 12。因此，本系統將採用  
  **Webhook 為主，定時輪詢為輔的混合式架構**，以確保資料同步的可靠性與效率。  
* **資料流 1：Airflow \-\> Notion (事件驅動)**  
  * **觸發**：利用 Firebase Functions 的 onWrite 觸發器，監聽 orders 集合的任何文件建立或更新事件。  
  * **執行**：當事件觸發時，該函式不會直接呼叫 Notion API。而是將訂單 ID 和變更類型等資訊，作為一個任務 (Task) 推送到 **Google Cloud Tasks** 佇列中。  
  * **處理**：另一個獨立的 HTTP 觸發的 Firebase Function 作為任務處理器，從佇列中取出任務，並以受控的速率（例如，每秒不超過 2 次）向 Notion API 發送 createPage 或 updatePage 的請求。  
  * **設計理由**：使用任務佇列是此流程的關鍵。它將訂單操作與 Notion API 的調用完全解耦，有效避免了因訂單量瞬間暴增而觸發 Notion 的速率限制。即使 Notion API 短暫故障，任務也會在佇列中等待重試，大大提升了同步的穩定性。  
* **資料流 2：Notion \-\> Airflow (Webhook \+ 輪詢備援)**  
  * **主要觸發 (Webhook)**：在 Notion Integration 設定中，配置一個 Webhook，使其在目標資料庫發生變更時觸發 15。此 Webhook 的 URL 將指向一個專門用於接收通知的 Firebase Function。  
  * **Webhook 處理**：Notion 的 Webhook Payload 通常只包含發生變更的頁面 ID，而不包含完整的頁面內容 15。因此，接收函式的主要職責是：  
    1. 驗證請求的 X-Notion-Signature 簽名，確保請求來自 Notion 15。  
    2. 從 Payload 中提取頁面 ID。  
    3. 使用該 ID，向 Notion API 發起一次 retrievePage 的請求，獲取完整的訂單更新資料。  
    4. 將獲取的資料解析並更新至 Firestore 中對應的 orders 文件。  
  * **備援觸發 (定時輪詢)**：為防止 Webhook 事件遺失，將設定一個使用 Cloud Scheduler 觸發的 Firebase Function，例如每小時執行一次。此函式會查詢 Notion 資料庫，篩選出所有 last\_edited\_time 晚於上次成功同步時間戳的頁面，並對這些頁面進行資料校對與更新。這個備援機制確保了最終的資料一致性 17。  
* **衝突解決機制**：為避免雙向同步可能造成的資料覆蓋問題，orders 文件和 Notion 頁面都將儲存一個 updatedAt (或 last\_edited\_time) 時間戳。系統將採用「**最後寫入者獲勝 (Last Write Wins)**」的原則。無論更新來自哪個方向，只有當傳入資料的時間戳比現有資料的時間戳更新時，才會執行寫入操作。  
* **模組化設計**：整個 Notion 同步功能將被封裝在獨立的 Firebase Functions 中。系統將在環境變數中設定一個 NOTION\_SYNC\_ENABLED 的布林值開關。所有相關的觸發器和 API 呼叫都會先檢查此開關。未來若要停用此功能，只需將此變數設為 false 並重新部署，即可在不影響核心訂單系統的情況下完全停用同步功能，完美符合模組化的要求 1。

## **7\. 建議擴充功能區塊 (專家建議)**

基於對 B2B 批發業務模式的理解，以下是建議擴充的功能模組，以提升平台的商業價值與營運效率。

### **7.1. 進階庫存管理**

* **理由**：目前的需求規格中缺乏庫存管理機制，這對於任何實體商品交易的批發業務都是至關重要的。無庫存管理將導致超賣、訂單延遲和客戶滿意度下降等嚴重問題。  
* **建議方案**：  
  1. **資料模型擴充**：在 products 集合中增加 stockQuantity (Number) 欄位。  
  2. **庫存連動**：當訂單狀態變為「已確認」或「處理中」時，自動扣減對應商品的庫存數量。當訂單被取消時，則回補庫存。  
  3. **後台管理**：在後台產品管理介面中，提供庫存數量的盤點與手動調整功能。  
  4. **低庫存警示**：建立一個自動化機制，當商品庫存低於預設閾值時，自動向管理員發送電子郵件通知。  
  5. **前台顯示**：可選擇性地在前台顯示庫存狀態，如「庫存充足」、「庫存緊張」或「已售罄」。

### **7.2. 業務員專屬門戶 (Salesperson Portal) \- Phase 2**

* **理由**：目前業務員在系統中是被動角色，無法即時了解自己的業績表現，這限制了他們的積極性與參與感 1。為他們提供一個專屬的資訊門戶，能極大地提升銷售團隊的動力與效率。  
* **建議方案**：  
  1. **新角色與認證**：在 Firebase Authentication 中建立一個新的 "salesperson" 角色，並為他們提供獨立的登入頁面。  
  2. **唯讀儀表板**：建立一個簡單的業務員專屬儀表板，登入後可查看以下唯讀資訊：  
     * **績效總覽**：本月/本季的總銷售額、訂單數量、新客戶註冊數。  
     * **客戶列表**：顯示所有透過其推薦碼註冊的客戶名單。  
     * **訂單記錄**：顯示所有歸屬於其名下的訂單列表及狀態。  
  3. **權限隔離**：嚴格設計 Firestore 安全規則，確保業務員只能讀取與自己 referralCodeId 相關的客戶與訂單資料，無法查看其他業務員的績效或敏感的商品成本資訊。

## **8\. 非功能性需求**

### **8.1. 易用性 (Usability)**

* 後台 CRM 介面需遵循直觀、簡潔的設計原則。操作流程應盡可能扁平化，減少不必要的點擊次數，降低管理員的學習成本與操作負擔 1。

### **8.2. 安全性 (Security)**

* **資料隔離**：客戶資料與價格資訊必須嚴格隔離。Firestore 安全規則是實現此目標的核心，必須確保任何客戶在任何情況下都無法讀取到其他客戶的個人資料、訂單歷史或專屬價格 1。  
* **存取控制**：所有後台 API 端點 (Firebase Functions) 都必須進行身份驗證與角色檢查，確保只有具備 admin 或 salesperson 角色的使用者才能存取後台，並根據其角色嚴格限制其可執行的操作。  
* **輸入驗證**：所有接收客戶端輸入的 API 端點，都必須使用如 Zod 等驗證函式庫，對傳入的資料進行嚴格的格式與型別檢查，防止惡意或格式錯誤的資料污染資料庫。

### **8.3. 模組化 (Modularity)**

* Notion 訂單同步功能必須作為一個獨立模組進行開發。其所有程式碼與觸發器應與核心訂單系統低耦合，並由一個全域設定開關控制其啟用狀態，確保未來可以被輕鬆移除而不產生任何副作用 1。

### **8.4. 可維護性 (Maintainability)**

* **UI 集中管理**：所有全域樣式、主題設定與共用元件必須在統一的位置進行管理，嚴禁針對單獨頁面編寫重複或獨立的樣式碼 1。  
* **避免硬編碼**：系統中所有可配置的變數，如 API 路徑、預設設定值、外部服務金鑰等，都必須透過環境變數或資料庫設定檔進行管理，不得寫死在程式碼中 1。

## **9\. 部署與配置說明**

### **9.1. Firebase 專案設定**

* **啟用服務**：在 Firebase 控制台中，需啟用以下服務：  
  * Authentication (啟用 Email/Password 登入方式)  
  * Firestore Database (在測試模式下建立)  
  * Storage  
  * Functions  
* **Firestore 索引**：根據 3\. 資料模型一節中標示的「需索引」欄位，在 Firebase 控制台中手動建立對應的複合索引，以確保查詢效能。

### **9.2. Next.js SSR 應用部署至 Firebase**

本專案將利用 Firebase CLI 的 Web Frameworks 整合功能來部署具備伺服器端渲染 (SSR) 的 Next.js 應用。

* **部署流程**：  
  1. **安裝/更新 Firebase CLI**：確保本機安裝的 firebase-tools 為 12.1.0 或更新版本 2。  
  2. **啟用實驗性功能**：在專案根目錄執行指令 $ firebase experiments:enable webframeworks 2。  
  3. **初始化專案**：執行 $ firebase init hosting。  
  4. **遵循提示**：  
     * 選擇或建立一個 Firebase 專案。  
     * 當詢問「Do you want to use a web framework? (experimental)」時，回答 yes。  
     * 選擇 Next.js 作為您的框架。  
  5. **自動配置**：Firebase CLI 會自動檢測專案中的 SSR 頁面 (使用 getServerSideProps 的頁面)，並在 firebase.json 中生成配置，將這些頁面的渲染請求重寫到一個專門的 Cloud Function 2。  
  6. **部署**：執行 $ firebase deploy 指令，CLI 會將靜態資源上傳至 Hosting，並將後端邏輯打包部署至 Cloud Functions。  
* **部署建議**：根據 Firebase 的官方文件，對於新的全端 Next.js 專案，強烈建議評估使用其較新的 **Firebase App Hosting** 產品。App Hosting 提供了更為整合與簡化的部署體驗，將 CDN、SSR 和 GitHub 整合等功能統一管理，可能是比傳統 Hosting \+ Functions 組合更優的選擇 2。

### **9.3. 環境變數配置**

系統的正常運行依賴於一系列的環境變數。這些變數需要在部署環境中（如 Firebase Functions 的環境變數設定）進行配置。

**表 9.1：必要環境變數**

| 變數名稱 | 描述 | 範例值 |
| :---- | :---- | :---- |
| NEXT\_PUBLIC\_FIREBASE\_API\_KEY | Firebase Web App 的 API 金鑰。 | AIzaSy... |
| NEXT\_PUBLIC\_FIREBASE\_AUTH\_DOMAIN | Firebase 專案的認證網域。 | project-id.firebaseapp.com |
| NEXT\_PUBLIC\_FIREBASE\_PROJECT\_ID | Firebase 專案 ID。 | your-project-id |
| NEXT\_PUBLIC\_FIREBASE\_STORAGE\_BUCKET | Firebase 儲存桶的網址。 | project-id.appspot.com |
| NEXT\_PUBLIC\_FIREBASE\_MESSAGING\_SENDER\_ID | Firebase 訊息發送者 ID。 | 1234567890 |
| NEXT\_PUBLIC\_FIREBASE\_APP\_ID | Firebase 應用程式 ID。 | 1:123...:web:... |
| NOTION\_API\_KEY | 用於 Notion API 驗證的內部整合權杖。 | secret\_... |
| NOTION\_DATABASE\_ID | 要進行同步的 Notion 資料庫 ID。 | a1b2c3d4... |
| NOTION\_SYNC\_ENABLED | Notion 同步功能的總開關。設為 "true" 以啟用。 | "true" |
| NOTION\_WEBHOOK\_SECRET | 用於驗證 Notion Webhook 請求的密鑰 (即 verification\_token) 15。 | your-secret-token |

## **10\. 網頁介面設計與使用者體驗 (UI/UX)**

本節詳細描述前後台的介面設計原則，旨在建立一個專業、可信且易於使用的企業級平台。

### **10.1. 前台 (客戶門戶) 設計：建立信任感與專業形象**

前台是直接面對批發客戶的門面，其核心設計目標是傳達**專業性、可靠性與易用性**，從而建立強大的客戶信任感。

* **整體風格與佈局**：  
  * **設計語言**：採用現代、簡潔的設計風格。大量運用留白，避免視覺混亂，讓使用者的注意力能集中在商品與關鍵資訊上。  
  * **佈局結構**：採用清晰的頂部導航欄、主要內容區塊及專業的頁尾。導航欄應包含 Logo、商品分類、我的帳戶、購物車及通知中心等核心入口。  
  * **品牌色彩應用**：橘藍漸層主題色將被策略性地應用於關鍵的行動呼籲 (Call-to-Action) 按鈕（如「加入購物車」、「提交訂單」）、焦點狀態及網站 Logo，以強化品牌識別度，同時引導使用者操作。  
* **關鍵頁面設計**：  
  * **登入/註冊頁**：介面應極度簡潔，避免任何不必要的干擾。表單欄位清晰，並提供明確的錯誤提示。  
  * **客戶儀表板 (登入後首頁)**：轉變為一個個人化的儀表板。頂部是根據客戶群組顯示的專屬橫幅，下方則以卡片形式展示「最近訂單」、「常用採購清單」等快捷入口，提升採購效率。  
  * **商品列表與詳情頁**：  
    * **視覺呈現**：商品圖片必須高品質且可放大檢視。列表頁提供清晰的篩選與排序功能。  
    * **資訊架構**：商品詳情頁的資訊層次分明，價格（登入後）與「加入購物車」按鈕最為突出。商品描述將利用富文本編輯器的排版能力，以易於閱讀的方式呈現。  
  * **結帳流程**：  
    * **引導式設計**：採用多步驟流程（例如：1. 確認商品 \-\> 2\. 選擇地址 \-\> 3\. 完成下單），並在頁面頂部提供進度條，讓客戶清楚了解目前所在的步驟，降低操作焦慮感。  
    * **最小化干擾**：在結帳流程中，應隱藏非必要的導航連結，讓使用者專注於完成訂單。

### **10.2. 後台 (管理與業務門戶) 設計：追求效率與降低學習成本**

後台是內部營運的核心，設計目標是**高效率、直觀性與低學習成本**，確保管理員與業務員都能快速上手，輕鬆完成日常工作。

* **整體風格與佈局**：  
  * **設計語言**：採用功能導向的儀表板設計風格。以數據清晰、操作便捷為首要原則。  
  * **佈局結構**：採用業界標準的**三段式佈局**：  
    1. **左側：可收合的側邊導航欄**，以圖示加文字的形式清晰列出所有功能模組（儀表板、訂單、客戶、產品等）。  
    2. **頂部：標頭區**，包含使用者名稱、角色、通知及登出按鈕。  
    3. **中央：主要內容工作區**，用於顯示列表、表單或數據圖表。  
  * **一致性**：所有頁面的操作邏輯（如新增、編輯、刪除按鈕的位置與樣式）和元件（如表格、表單、模態框）都將保持高度一致，使用者學會操作一個模組後，即可觸類旁通。  
* **角色化介面設計 (Role-Based Interface)**：  
  * **管理員視圖 (Admin View)**：  
    * **儀表板**：採用可自訂的網格佈局，以多個小工具 (Widgets) 呈現全站的關鍵績效指標 (KPIs)，如銷售趨勢圖、熱銷商品排行、待辦事項列表（待審核客戶、待處理訂單）等。  
    * **數據表格**：所有列表頁（如訂單、客戶列表）都將是功能強大的數據表格，內建**即時搜尋、多欄位篩選、點擊表頭排序**等功能，並支援數據匯出。  
    * **表單設計**：所有編輯和新增頁面的表單都將邏輯分組，複雜表單（如產品編輯）將使用頁籤 (Tabs) 來分類不同屬性，避免頁面過長。  
  * **業務員視圖 (Salesperson View)**：  
    * **簡化導航**：業務員登入後，左側導航欄將**只顯示其擁有權限的項目**：「儀表板」、「我的客戶」、「我的訂單」及「個人設定」。  
    * **專屬儀表板**：儀表板上顯示的數據將被嚴格過濾，僅呈現與該業務員相關的績效指標。  
    * **唯讀數據**：「我的客戶」和「我的訂單」頁面將採用與管理員視圖相同的數據表格元件，但**移除所有編輯與刪除功能**，僅供查詢。  
    * **專注的設定頁**：其「個人設定」頁面將是一個極簡的表單，僅包含允許他們修改的欄位（如 LINE 資訊），隱藏所有其他系統設定，從而極大地降低了誤操作的風險與學習成本。

#### **引用的著作**

1. 需求文件-1.pdf  
2. Integrate Next.js | Firebase Hosting \- Google, 檢索日期：9月 3, 2025， [https://firebase.google.com/docs/hosting/frameworks/nextjs](https://firebase.google.com/docs/hosting/frameworks/nextjs)  
3. Next.js 14 with Firebase: A Practical Walkthrough \- DEV Community, 檢索日期：9月 3, 2025， [https://dev.to/wadizaatour/integrating-nextjs-with-firebase-a-practical-walkthrough-4j30](https://dev.to/wadizaatour/integrating-nextjs-with-firebase-a-practical-walkthrough-4j30)  
4. Which rich text editor framework should you choose in 2025? | Liveblocks blog, 檢索日期：9月 3, 2025， [https://liveblocks.io/blog/which-rich-text-editor-framework-should-you-choose-in-2025](https://liveblocks.io/blog/which-rich-text-editor-framework-should-you-choose-in-2025)  
5. What the best rich text editor library? \- nextjs \- Reddit, 檢索日期：9月 3, 2025， [https://www.reddit.com/r/nextjs/comments/1e5lvdk/what\_the\_best\_rich\_text\_editor\_library/](https://www.reddit.com/r/nextjs/comments/1e5lvdk/what_the_best_rich_text_editor_library/)  
6. Choosing a good Rich Text Editor : r/nextjs \- Reddit, 檢索日期：9月 3, 2025， [https://www.reddit.com/r/nextjs/comments/1cn1i7d/choosing\_a\_good\_rich\_text\_editor/](https://www.reddit.com/r/nextjs/comments/1cn1i7d/choosing_a_good_rich_text_editor/)  
7. Get started with Liveblocks, Tiptap, and Next.js, 檢索日期：9月 3, 2025， [https://liveblocks.io/docs/get-started/nextjs-tiptap](https://liveblocks.io/docs/get-started/nextjs-tiptap)  
8. Upload files with Cloud Storage on Web \- Firebase, 檢索日期：9月 3, 2025， [https://firebase.google.com/docs/storage/web/upload-files](https://firebase.google.com/docs/storage/web/upload-files)  
9. Upload files with Cloud Storage on Android \- Firebase, 檢索日期：9月 3, 2025， [https://firebase.google.com/docs/storage/android/upload-files](https://firebase.google.com/docs/storage/android/upload-files)  
10. Writing Rich-Text Content to Cloud Firestore With Tiptap and Nuxt \- Don Lalicon, 檢索日期：9月 3, 2025， [https://donlalicon.dev/articles/writing-rich-text-content-firestore-tiptap-nuxt](https://donlalicon.dev/articles/writing-rich-text-content-firestore-tiptap-nuxt)  
11. Request limits \- Notion API, 檢索日期：9月 3, 2025， [https://developers.notion.com/reference/request-limits](https://developers.notion.com/reference/request-limits)  
12. Polling vs webhooks: when to use one over the other \- Merge.dev, 檢索日期：9月 3, 2025， [https://www.merge.dev/blog/webhooks-vs-polling](https://www.merge.dev/blog/webhooks-vs-polling)  
13. Webhooks vs. Polling: Understanding the Difference with Real-Life Examples | by i.vikash, 檢索日期：9月 3, 2025， [https://medium.com/@i.vikash/webhooks-vs-polling-understanding-the-difference-with-real-life-examples-b1ba1074328a](https://medium.com/@i.vikash/webhooks-vs-polling-understanding-the-difference-with-real-life-examples-b1ba1074328a)  
14. Polling vs Webhooks \- ByteByteGo, 檢索日期：9月 3, 2025， [https://bytebytego.com/guides/polling-vs-webhooks/](https://bytebytego.com/guides/polling-vs-webhooks/)  
15. Webhooks \- Notion API, 檢索日期：9月 3, 2025， [https://developers.notion.com/reference/webhooks](https://developers.notion.com/reference/webhooks)  
16. Understanding Notion webhook event data structure and implementation, 檢索日期：9月 3, 2025， [https://community.latenode.com/t/understanding-notion-webhook-event-data-structure-and-implementation/23098](https://community.latenode.com/t/understanding-notion-webhook-event-data-structure-and-implementation/23098)  
17. Triggering API calls when database properties change in Notion \- Latenode community, 檢索日期：9月 3, 2025， [https://community.latenode.com/t/triggering-api-calls-when-database-properties-change-in-notion/36067](https://community.latenode.com/t/triggering-api-calls-when-database-properties-change-in-notion/36067)  
18. Integrate Firebase with a Next.js app \- Google, 檢索日期：9月 3, 2025， [https://firebase.google.com/codelabs/firebase-nextjs](https://firebase.google.com/codelabs/firebase-nextjs)